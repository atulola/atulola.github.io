<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Solar System</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial;
}
#ui {
    position: absolute;
    top: 15px;
    left: 15px;
    color: white;
    z-index: 10;
}
input {
    width: 220px;
}
</style>
</head>

<body>

<div id="ui">
    <h2>Solar System Speed Control</h2>
    <label>Orbit Speed</label><br>
    <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth/window.innerHeight,
    0.1,
    2000
);
camera.position.set(0, 120, 300);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = true;

// ‚≠ê Stars Background
const starGeometry = new THREE.BufferGeometry();
const starVertices = [];
for(let i=0;i<12000;i++){
    starVertices.push(
        THREE.MathUtils.randFloatSpread(2000),
        THREE.MathUtils.randFloatSpread(2000),
        THREE.MathUtils.randFloatSpread(2000)
    );
}
starGeometry.setAttribute('position',
    new THREE.Float32BufferAttribute(starVertices,3));
const starMaterial = new THREE.PointsMaterial({color:0xffffff});
const stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);

// üåû GLOWING SUN
const sunGeometry = new THREE.SphereGeometry(20, 64, 64);
const sunMaterial = new THREE.MeshBasicMaterial({
    color: 0xffcc00
});
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
scene.add(sun);

// Sun glow halo
const glowGeometry = new THREE.SphereGeometry(28, 64, 64);
const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xffaa00,
    transparent: true,
    opacity: 0.4
});
const glow = new THREE.Mesh(glowGeometry, glowMaterial);
scene.add(glow);

const light = new THREE.PointLight(0xffffff, 2, 2000);
scene.add(light);

// üåç Planet Creation
let planets = [];

function createPlanet(size, distance, color, speed, name) {
    const geometry = new THREE.SphereGeometry(size, 32, 32);
    const material = new THREE.MeshStandardMaterial({color});
    const mesh = new THREE.Mesh(geometry, material);

    const pivot = new THREE.Object3D();
    scene.add(pivot);
    pivot.add(mesh);

    mesh.position.x = distance;

    planets.push({mesh, pivot, speed});
    mesh.userData = { name };

    return mesh;
}

// üåë Moons
function createMoon(parent, size, distance, speed) {
    const geometry = new THREE.SphereGeometry(size, 16, 16);
    const material = new THREE.MeshStandardMaterial({color:0xaaaaaa});
    const moon = new THREE.Mesh(geometry, material);

    const pivot = new THREE.Object3D();
    parent.add(pivot);
    pivot.add(moon);
    moon.position.x = distance;

    planets.push({mesh:moon, pivot, speed});
}

// Planets
const mercury = createPlanet(4, 40, 0xaaaaaa, 0.04, "mercury2.html");
const venus = createPlanet(6, 60, 0xffaa00, 0.015, "venus2.html");
const earth = createPlanet(7, 85, 0x2233ff, 0.01, "earth2.html");
const mars = createPlanet(5, 110, 0xff3300, 0.008, "mars2.html");
const jupiter = createPlanet(15, 150, 0xffaa88, 0.002, "jupiter2.html");
const saturn = createPlanet(13, 200, 0xffddaa, 0.0009, "saturn2.html");
const uranus = createPlanet(10, 240, 0x66ffff, 0.0004, "uranus2.html");
const neptune = createPlanet(10, 280, 0x3333ff, 0.0001, "neptune2.html");

// Moons
createMoon(earth,2,15,0.05);
createMoon(mars,1.5,10,0.06);
createMoon(jupiter,2,25,0.04);
createMoon(saturn,2,30,0.03);

// ü™® Asteroid Belt
for(let i=0;i<500;i++){
    const geo = new THREE.SphereGeometry(0.8,6,6);
    const mat = new THREE.MeshStandardMaterial({color:0x888888});
    const asteroid = new THREE.Mesh(geo,mat);
    const angle = Math.random()*Math.PI*2;
    const radius = 130 + Math.random()*20;
    asteroid.position.set(
        Math.cos(angle)*radius,
        (Math.random()-0.5)*10,
        Math.sin(angle)*radius
    );
    scene.add(asteroid);
}

// ‚òÑÔ∏è Comet
const cometGeo = new THREE.SphereGeometry(2,16,16);
const cometMat = new THREE.MeshBasicMaterial({color:0xffffff});
const comet = new THREE.Mesh(cometGeo, cometMat);
scene.add(comet);
let cometAngle = 0;

// ‚òÑÔ∏è Meteors
for(let i=0;i<40;i++){
    const geo = new THREE.SphereGeometry(1,8,8);
    const mat = new THREE.MeshBasicMaterial({color:0xffaa00});
    const meteor = new THREE.Mesh(geo,mat);
    meteor.position.set(
        THREE.MathUtils.randFloatSpread(1000),
        THREE.MathUtils.randFloatSpread(500),
        THREE.MathUtils.randFloatSpread(1000)
    );
    scene.add(meteor);
}

// Speed Control
let globalSpeed = 1;
document.getElementById("speedControl").addEventListener("input", function(){
    globalSpeed = parseFloat(this.value);
});

// Click navigation
window.addEventListener("click", function(event){
    const mouse = new THREE.Vector2(
        (event.clientX/window.innerWidth)*2-1,
        -(event.clientY/window.innerHeight)*2+1
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(
        planets.map(p=>p.mesh)
    );
    if(intersects.length>0){
        window.location.href = intersects[0].object.userData.name;
    }
});

// Animation
function animate(){
    requestAnimationFrame(animate);

    planets.forEach(p=>{
        p.pivot.rotation.y += p.speed * globalSpeed;
        p.mesh.rotation.y += 0.01;
    });

    cometAngle += 0.01;
    comet.position.set(
        Math.cos(cometAngle)*400,
        50,
        Math.sin(cometAngle)*400
    );

    controls.update();
    renderer.render(scene,camera);
}
animate();

window.addEventListener("resize", function(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
  </html>
